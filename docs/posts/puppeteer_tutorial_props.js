import projectConfig from '/pagic.config.js';
export default {
    config: { "root": "/", ...projectConfig, branch: '' },
    'pagePath': "posts/puppeteer_tutorial.md",
    'layoutPath': "posts/_layout.tsx",
    'outputPath': "posts/puppeteer_tutorial.html",
    'title': "Puppeteer 指南",
    'content': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<h1>Puppeteer 指南</h1>\n<p>Puppeteer 是 Google Chrome 出品的一个无头浏览器。如果你听说过 Phantomjs 或者 Selenium，那么就应该知道它是做什么的了。Puppeteer 与它们类似，提供了一系列 api，通过 DevTools 协议控制 Chromium/Chrome 浏览器的行为。</p>\n<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8">什么是无头浏览器<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8">§</a></h2>\n<p>无头浏览器就是没有用户界面的浏览器，即通过写脚本来使用无头浏览器访问网站，还可以做一些点击等行为。</p>\n<p>Puppeteer 一般使用无头的模式运行，这样的开销较小。当然也提供了使用完整的 Chromium/Chrome 来运行的模式。</p>\n<h2 id="puppeteer-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">Puppeteer 能做什么<a class="anchor" href="#puppeteer-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">§</a></h2>\n<p>能够做几乎所有浏览器能做的事情。</p>\n<ul>\n<li>网页截图，或生成 pdf</li>\n<li>爬取 SPA 或 SSR 网站</li>\n<li>自动化表单提交，UI测试，键盘输入等</li>\n<li>创建一个最新的自动化测试环境。使用最新的 js 和最新的 Chrome 浏览器运行测试用例</li>\n<li>捕获网站的时间线，帮助诊断性能问题</li>\n<li>测试 Chrome 插件</li>\n</ul>\n<h2 id="puppeteer-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Puppeteer 与其他无头浏览器有什么区别？<a class="anchor" href="#puppeteer-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">§</a></h2>\n<ul>\n<li>Puppeteer 由 Google Chrome 维护，速度快、安全、稳定、易用</li>\n<li>其他无头浏览器可以支持多种浏览器环境（Safari, Chrome, Firefox 等），而 Puppeteer 只支持 Chromium/Chrome</li>\n<li>Puppeteer 有完善的事件系统，不需要频繁的 <code>sleep(1000)</code> 了</li>\n<li>Puppeteer 的调试功能很强大，还支持在 DevTools 里面调试</li>\n<li>Puppeteer 能够创建一个「真实」的行为，如点击</li>\n</ul>\n<h2 id="%E5%AE%89%E8%A3%85-puppeteer">安装 Puppeteer<a class="anchor" href="#%E5%AE%89%E8%A3%85-puppeteer">§</a></h2>\n<p>先创建一个测试用的项目，执行 <code>npm init</code> 初始化好 <code>package.json</code>，然后执行以下命令安装 Puppeteer：</p>\n<pre class="language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> puppeteer --save-dev\n</code></pre>\n<p>万事开头难，第一步安装时就会遇到问题（如果没有报错，请跳过这一段）。</p>\n<p>Puppeteer 安装过程中会去下载 Chromium，墙内用户则会报错。如果你看到以下信息，说明是下载 Chromium 时连接不上。</p>\n<pre class="language-bash"><code class="language-bash">ERROR: Failed to download Chromium r588429<span class="token operator">!</span> Set <span class="token string">"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD"</span> <span class="token function">env</span> variable to skip download.\nError: Download failed: server returned code <span class="token number">502</span>. URL: <a class="token url-link" href="https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip">https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip</a>\n</code></pre>\n<p>或者</p>\n<pre class="language-bash"><code class="language-bash">ERROR: Failed to download Chromium r588429<span class="token operator">!</span> Set <span class="token string">"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD"</span> <span class="token function">env</span> variable to skip download.\n<span class="token punctuation">{</span> Error: connect ETIMEDOUT <span class="token number">172.217</span>.24.48:443\n</code></pre>\n<p>如提示所说，设置 <code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD</code> 可以跳过安装 Chromium。</p>\n<pre class="language-bash"><code class="language-bash"><span class="token assign-left variable">PUPPETEER_SKIP_CHROMIUM_DOWNLOAD</span><span class="token operator">=</span><span class="token number">1</span> <span class="token function">npm</span> <span class="token function">install</span> puppeteer --save-dev\n</code></pre>\n<p>此时可以安装成功，但是使用 Puppeteer 时会由于找不到 Chromium 而报错。可以创建一个文件 <code>test.js</code>，内容如下：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> puppeteer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'puppeteer\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> browser <span class="token operator">=</span> <span class="token keyword control-flow">await</span> puppeteer<span class="token punctuation">.</span><span class="token method function property-access">launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> page <span class="token operator">=</span> <span class="token keyword control-flow">await</span> browser<span class="token punctuation">.</span><span class="token method function property-access">newPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">await</span> page<span class="token punctuation">.</span><span class="token method function property-access">goto</span><span class="token punctuation">(</span><span class="token string">\'<a class="token url-link" href="https://example.com">https://example.com</a>\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">await</span> page<span class="token punctuation">.</span><span class="token method function property-access">screenshot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token operator">:</span> <span class="token string">\'example.png\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword control-flow">await</span> browser<span class="token punctuation">.</span><span class="token method function property-access">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>然后执行 <code>node test.js</code> 则会报错：</p>\n<pre class="language-bash"><code class="language-bash">$ node test.js\n<span class="token punctuation">(</span>node:18368<span class="token punctuation">)</span> UnhandledPromiseRejectionWarning: Unhandled promise rejection <span class="token punctuation">(</span>rejection id: <span class="token number">1</span><span class="token punctuation">)</span>: Error: Chromium revision is not downloaded. Run <span class="token string">"npm install"</span> or <span class="token string">"yarn install"</span>\n<span class="token punctuation">(</span>node:18368<span class="token punctuation">)</span> <span class="token punctuation">[</span>DEP0018<span class="token punctuation">]</span> DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero <span class="token builtin class-name">exit</span> code.\n</code></pre>\n<p>一个解决方案是先手动下载 Chromium，然后在执行时通过配置指定 Chromium 位置，<a href="https://juejin.im/post/5b4a043751882519790c7ad7">这篇文章</a>给出了解决步骤。</p>\n<p>但是我更倾向于还原 Puppeteer 安装时的过程。但是由于一些环境原因，即便翻墙了也只能手动下载 Chromium，无法在安装 Puppeteer 时自动下载 Chromium。</p>\n<p>读了一下源码之后，可以这么解决：</p>\n<ol>\n<li>安装 Puppeteer，安装失败，提示无法下载 <code>https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip</code></li>\n<li>使用 <code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1 npm install puppeteer --save-dev</code> 成功安装 Puppeteer</li>\n<li>执行 <code>node test.js</code> 提示无法找到 Chromium</li>\n<li>手动下载步骤 1 中的 <code>chrome-win32.zip</code>，注意不同版本、不同系统的下载地址是不一样的</li>\n<li>开启一个静态文件服务，使得 <code>http://127.0.0.1:8000/chrome-win32.zip</code> 指向需要下载的文件</li>\n<li>改写 <code>downloadURL</code> 方法，使其直接返回 <code>http://127.0.0.1:8000/chrome-win32.zip</code></li>\n<li>执行 <code>node ./node_modules/puppeteer/install.js</code> 完成安装</li>\n<li>执行 <code>node test.js</code> 测试能否成功生成截图</li>\n</ol>\n<p>至此，成功完成了 Puppeteer 的安装。</p>\n<h2 id="puppeteer-%E7%BB%93%E6%9E%84">Puppeteer 结构<a class="anchor" href="#puppeteer-%E7%BB%93%E6%9E%84">§</a></h2>\n<p>Puppeteer 通过 DevTools 协议控制 Chromium/Chrome 浏览器。它的结构和浏览器结构类似。</p>\n<blockquote>\n<p>下图中淡化显示的可以忽略</p>\n</blockquote>\n<p><img src="../assets/puppeteer_turorial/puppeteer-structure.png" alt="Puppeteer 结构"></p>\n<ul>\n<li>Puppeteer 通过 DevTools 协议控制 Chromium/Chrome 浏览器</li>\n<li>一个浏览器（Browser）实例可以包含多个浏览器上下文（Browser contexts），就像我们打开一个普通的 Chrome 之后又打开一个隐身模式的 Chrome</li>\n<li>一个浏览器上下文（BrowserContext）可以包含多个页面（Pages）</li>\n<li>一个页面（Page）包含至少一个主 frame，也可以包含其他 frames（在主 frame 中通过 iframe 或 frame 标签创建的）</li>\n<li>一个 frame 包含至少一个执行上下文（Execution context），也可以包含其他执行上下文（由 Chrome 插件创建的）</li>\n<li>一个 Workder 包含一个执行上下文，由 WebWorker 创建</li>\n</ul>\n<h2 id="puppeteer-api">Puppeteer API<a class="anchor" href="#puppeteer-api">§</a></h2>\n<p>Puppeteer 的大部分 API 的返回值都是 <code>Promise</code>，故推荐使用 <code>async</code> <code>await</code> 来处理异步操作。Puppeteer 的 API 包含以下类：</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>类名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Puppeteer</code></td>\n<td>主要用于创建一个浏览器实例，也可以用来下载新的 Chromium，或者设置浏览器的默认参数</td>\n</tr>\n<tr>\n<td><code>BrowserFetcher</code></td>\n<td>用于下载和管理 Chromium</td>\n</tr>\n<tr>\n<td><code>Browser</code></td>\n<td>可以创建一个或多个 Page</td>\n</tr>\n<tr>\n<td><code>BrowserContext</code></td>\n<td>创建一个隐身模式的浏览器时需要用到</td>\n</tr>\n<tr>\n<td><code>Page</code></td>\n<td><strong>主要 API，用于操作一个页面，后面会详细介绍</strong></td>\n</tr>\n<tr>\n<td><code>Worker</code></td>\n<td>用于处理 WebWorker</td>\n</tr>\n<tr>\n<td><code>Keyboard</code></td>\n<td>可以触发键盘按键</td>\n</tr>\n<tr>\n<td><code>Mouse</code></td>\n<td>可以触发鼠标动作</td>\n</tr>\n<tr>\n<td><code>TouchScreen</code></td>\n<td>可以触发触摸屏的动作</td>\n</tr>\n<tr>\n<td><code>Tracing</code></td>\n<td>用于分析性能</td>\n</tr>\n<tr>\n<td><code>Dialog</code></td>\n<td>存在于 page 的 <code>dialog</code> 事件回调中，表示调用弹窗后的对象，包括 <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> 和 <code>prompt</code></td>\n</tr>\n<tr>\n<td><code>ConsoleMessage</code></td>\n<td>存在于 page 的 <code>console</code> 事件回调中，表示调用 <code>console.log</code> 等方法后的对象</td>\n</tr>\n<tr>\n<td><code>Frame</code></td>\n<td>常用于处理包含多个 frame 的页面。page 中的很多方法就是直接调用的主 frame 的方法</td>\n</tr>\n<tr>\n<td><code>ExecutionContext</code></td>\n<td>执行上下文存在于 frame、浏览器插件、worker 中。可以用来直接执行一段 js</td>\n</tr>\n<tr>\n<td><code>JSHandle</code></td>\n<td>通过 <code>page.evaluateHandle</code> 生成，用于将页面中的 handler 挑出来传递使用</td>\n</tr>\n<tr>\n<td><code>ElementHandle</code></td>\n<td>通过 <code>page.$</code> 生成，用于将页面中某个元素的 handler 挑出来传递使用</td>\n</tr>\n<tr>\n<td><code>Request</code></td>\n<td>在 <code>page.setRequestInterception</code> 方法中使用，可以处理页面的请求</td>\n</tr>\n<tr>\n<td><code>Response</code></td>\n<td>表示页面接收到的响应</td>\n</tr>\n<tr>\n<td><code>SecurityDetails</code></td>\n<td>表示页面的安全信息</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td>可以是 page, background_page, service_worker, browser 等</td>\n</tr>\n<tr>\n<td><code>CDPSession</code></td>\n<td>用于直接和 Devtools 通信</td>\n</tr>\n<tr>\n<td><code>Coverage</code></td>\n<td>用于分析 js 和 css 的代码被页面使用的比例</td>\n</tr>\n<tr>\n<td><code>TimeoutError</code></td>\n<td>超时错误</td>\n</tr>\n</tbody>\n</table></div>\n<h3 id="page">Page<a class="anchor" href="#page">§</a></h3>\n<p>Page 是 Puppeteer 中最重要的一个 API，也是它的核心所在，这里会介绍一些常用的 Page API。</p>\n<h4 id="%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%8E%AF%E5%A2%83">设置页面环境<a class="anchor" href="#%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%8E%AF%E5%A2%83">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.emulate</code></td>\n<td>设置 viewport 和 ua</td>\n</tr>\n<tr>\n<td><code>page.setViewport</code></td>\n<td>设置 viewport</td>\n</tr>\n<tr>\n<td><code>page.setUserAgent</code></td>\n<td>设置 ua</td>\n</tr>\n<tr>\n<td><code>page.setRequestInterception</code></td>\n<td><strong>中断所有请求，并可以修改请求的返回值</strong></td>\n</tr>\n<tr>\n<td><code>page.addScriptTag</code></td>\n<td>添加 js 脚本</td>\n</tr>\n<tr>\n<td><code>page.addStyleTag</code></td>\n<td>添加 css</td>\n</tr>\n<tr>\n<td><code>page.setContent</code></td>\n<td>设置整个 html</td>\n</tr>\n<tr>\n<td><code>page.setCacheEnabled</code></td>\n<td>设置缓存是否开启</td>\n</tr>\n<tr>\n<td><code>page.setExtraHTTPHeaders</code></td>\n<td>设置额外的 http 头</td>\n</tr>\n<tr>\n<td><code>page.setGeolocation</code></td>\n<td>设置地理位置</td>\n</tr>\n<tr>\n<td><code>page.setJavaScriptEnabled</code></td>\n<td>设置 js 是否开启</td>\n</tr>\n<tr>\n<td><code>page.setOfflineMode</code></td>\n<td>设置离线模式</td>\n</tr>\n<tr>\n<td><code>page.deleteCookie</code></td>\n<td>删除 cookies</td>\n</tr>\n<tr>\n<td><code>page.setCookie</code></td>\n<td>设置 cookies</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E6%A8%A1%E6%8B%9F%E5%8A%A8%E4%BD%9C">模拟动作<a class="anchor" href="#%E6%A8%A1%E6%8B%9F%E5%8A%A8%E4%BD%9C">§</a></h4>\n<p>一般会先滚动视窗到相应元素那，再执行动作。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.click</code></td>\n<td>点击</td>\n</tr>\n<tr>\n<td><code>page.tap</code></td>\n<td>手指点击</td>\n</tr>\n<tr>\n<td><code>page.focus</code></td>\n<td>聚焦</td>\n</tr>\n<tr>\n<td><code>page.hover</code></td>\n<td>hover</td>\n</tr>\n<tr>\n<td><code>page.type</code></td>\n<td>在指定元素中输入内容</td>\n</tr>\n<tr>\n<td><code>page.select</code></td>\n<td>选中 <code>&lt;select&gt;</code> 的某个选项</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E7%AD%89%E5%BE%85">等待<a class="anchor" href="#%E7%AD%89%E5%BE%85">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.waitFor</code></td>\n<td>等待某个元素渲染出来，或者某个函数执行之后返回 <code>true</code>，或者直接等待指定的时间</td>\n</tr>\n<tr>\n<td><code>page.waitForSelector</code></td>\n<td>等待某个元素被渲染</td>\n</tr>\n<tr>\n<td><code>page.waitForFunction</code></td>\n<td>等待某个函数执行之后返回 <code>true</code></td>\n</tr>\n<tr>\n<td><code>page.waitForNavigation</code></td>\n<td>等待页面跳转</td>\n</tr>\n<tr>\n<td><code>page.waitForRequest</code></td>\n<td>等待某个特定的请求被发出</td>\n</tr>\n<tr>\n<td><code>page.waitForResponse</code></td>\n<td>等待某个特定的请求收到了回应</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC">执行脚本<a class="anchor" href="#%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.$</code></td>\n<td>使用 <code>document.querySelector</code> 获取结果，会返回 <code>ElementHandle</code>，可以传递使用</td>\n</tr>\n<tr>\n<td><code>page.$$</code></td>\n<td>同上，不过使用的是 <code>document.querySelectorAll</code></td>\n</tr>\n<tr>\n<td><code>page.$eval</code></td>\n<td>将 <code>document.querySelector</code> 获取的结果传递给 <code>pageFunction</code></td>\n</tr>\n<tr>\n<td><code>page.$$eval</code></td>\n<td>同上，不过使用的是 <code>document.querySelectorAll</code></td>\n</tr>\n<tr>\n<td><code>page.evaluate</code></td>\n<td>直接执行脚本</td>\n</tr>\n<tr>\n<td><code>page.evaluateHandle</code></td>\n<td>执行脚本，返回的是 <code>JSHandle</code>，可以传递使用</td>\n</tr>\n<tr>\n<td><code>page.evaluateOnNewDocument</code></td>\n<td>在下个 frame 执行脚本</td>\n</tr>\n<tr>\n<td><code>page.exposeFunction</code></td>\n<td>将函数注入到 <code>window</code> 对象上</td>\n</tr>\n<tr>\n<td><code>page.queryObjects</code></td>\n<td>获取所有属于这个类的对象，可以传递使用</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC">页面跳转<a class="anchor" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.goto</code></td>\n<td>跳转页面</td>\n</tr>\n<tr>\n<td><code>page.close</code></td>\n<td>关闭</td>\n</tr>\n<tr>\n<td><code>page.goBack</code></td>\n<td>后退</td>\n</tr>\n<tr>\n<td><code>page.goForward</code></td>\n<td>前进</td>\n</tr>\n<tr>\n<td><code>page.reload</code></td>\n<td>刷新</td>\n</tr>\n<tr>\n<td><code>page.setDefaultNavigationTimeout</code></td>\n<td>设置页面跳转的超时时长</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9">获取内容<a class="anchor" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.screenshot</code></td>\n<td>截屏</td>\n</tr>\n<tr>\n<td><code>page.pdf</code></td>\n<td>生成 pdf</td>\n</tr>\n<tr>\n<td><code>page.content</code></td>\n<td>获取整个页面内容</td>\n</tr>\n<tr>\n<td><code>page.title</code></td>\n<td>获取页面 title</td>\n</tr>\n<tr>\n<td><code>page.url</code></td>\n<td>获取页面 url</td>\n</tr>\n<tr>\n<td><code>page.viewport</code></td>\n<td>获取页面 viewport</td>\n</tr>\n<tr>\n<td><code>page.cookies</code></td>\n<td>获取 cookies</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E4%BA%8B%E4%BB%B6">事件<a class="anchor" href="#%E4%BA%8B%E4%BB%B6">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>事件名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.on(\'console\')</code></td>\n<td>监听 <code>console.log</code> 等的调用</td>\n</tr>\n<tr>\n<td><code>page.on(\'dialog\')</code></td>\n<td>监听页面的 <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> 和 <code>prompt</code> 弹窗</td>\n</tr>\n<tr>\n<td><code>page.on(\'load\')</code></td>\n<td>监听页面的加载</td>\n</tr>\n<tr>\n<td><code>page.on(\'domcontentloaded\')</code></td>\n<td>监听页面 dom 加载完成</td>\n</tr>\n<tr>\n<td><code>page.on(\'pageerror\')</code></td>\n<td>监听页面错误</td>\n</tr>\n<tr>\n<td><code>page.on(\'request\')</code></td>\n<td>监听页面发送的请求</td>\n</tr>\n<tr>\n<td><code>page.on(\'requestfailed\')</code></td>\n<td>监听失败的请求</td>\n</tr>\n<tr>\n<td><code>page.on(\'requestfinished\')</code></td>\n<td>监听完成的请求</td>\n</tr>\n<tr>\n<td><code>page.on(\'response\')</code></td>\n<td>监听页面接受到的响应</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间<a class="anchor" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">§</a></h4>\n<p>通过一些命名空间可以快速访问到该页面下的其他实例。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.keyboard</code></td>\n<td>访问到页面的 Keyboard 对象</td>\n</tr>\n<tr>\n<td><code>page.mouse</code></td>\n<td>访问到页面的 Mouse 对象</td>\n</tr>\n<tr>\n<td><code>page.touchscreen</code></td>\n<td>访问到页面的 TouchScreen 对象</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id="links">Links<a class="anchor" href="#links">§</a></h2>\n<ul>\n<li><a href="https://pptr.dev/">Puppeteer 文档</a></li>\n<li><a href="https://peter.sh/experiments/chromium-command-line-switches/">Chromium CLI 参数</a></li>\n<li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js">预设的 EmulateOptions</a></li>\n</ul>'
        } }),
    'head': null,
    'script': React.createElement(React.Fragment, null,
        React.createElement("script", { src: "https://cdn.pagic.org/react@16.13.1/umd/react.production.min.js" }),
        React.createElement("script", { src: "https://cdn.pagic.org/react-dom@16.13.1/umd/react-dom.production.min.js" }),
        React.createElement("script", { src: "/index.js", type: "module" })),
    'contentTitle': React.createElement("h1", { key: "0" }, "Puppeteer \u6307\u5357"),
    'contentBody': React.createElement("article", { dangerouslySetInnerHTML: {
            __html: '<p>Puppeteer 是 Google Chrome 出品的一个无头浏览器。如果你听说过 Phantomjs 或者 Selenium，那么就应该知道它是做什么的了。Puppeteer 与它们类似，提供了一系列 api，通过 DevTools 协议控制 Chromium/Chrome 浏览器的行为。</p>\n<h2 id="%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8">什么是无头浏览器<a class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8">§</a></h2>\n<p>无头浏览器就是没有用户界面的浏览器，即通过写脚本来使用无头浏览器访问网站，还可以做一些点击等行为。</p>\n<p>Puppeteer 一般使用无头的模式运行，这样的开销较小。当然也提供了使用完整的 Chromium/Chrome 来运行的模式。</p>\n<h2 id="puppeteer-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">Puppeteer 能做什么<a class="anchor" href="#puppeteer-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88">§</a></h2>\n<p>能够做几乎所有浏览器能做的事情。</p>\n<ul>\n<li>网页截图，或生成 pdf</li>\n<li>爬取 SPA 或 SSR 网站</li>\n<li>自动化表单提交，UI测试，键盘输入等</li>\n<li>创建一个最新的自动化测试环境。使用最新的 js 和最新的 Chrome 浏览器运行测试用例</li>\n<li>捕获网站的时间线，帮助诊断性能问题</li>\n<li>测试 Chrome 插件</li>\n</ul>\n<h2 id="puppeteer-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Puppeteer 与其他无头浏览器有什么区别？<a class="anchor" href="#puppeteer-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">§</a></h2>\n<ul>\n<li>Puppeteer 由 Google Chrome 维护，速度快、安全、稳定、易用</li>\n<li>其他无头浏览器可以支持多种浏览器环境（Safari, Chrome, Firefox 等），而 Puppeteer 只支持 Chromium/Chrome</li>\n<li>Puppeteer 有完善的事件系统，不需要频繁的 <code>sleep(1000)</code> 了</li>\n<li>Puppeteer 的调试功能很强大，还支持在 DevTools 里面调试</li>\n<li>Puppeteer 能够创建一个「真实」的行为，如点击</li>\n</ul>\n<h2 id="%E5%AE%89%E8%A3%85-puppeteer">安装 Puppeteer<a class="anchor" href="#%E5%AE%89%E8%A3%85-puppeteer">§</a></h2>\n<p>先创建一个测试用的项目，执行 <code>npm init</code> 初始化好 <code>package.json</code>，然后执行以下命令安装 Puppeteer：</p>\n<pre class="language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> puppeteer --save-dev\n</code></pre>\n<p>万事开头难，第一步安装时就会遇到问题（如果没有报错，请跳过这一段）。</p>\n<p>Puppeteer 安装过程中会去下载 Chromium，墙内用户则会报错。如果你看到以下信息，说明是下载 Chromium 时连接不上。</p>\n<pre class="language-bash"><code class="language-bash">ERROR: Failed to download Chromium r588429<span class="token operator">!</span> Set <span class="token string">"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD"</span> <span class="token function">env</span> variable to skip download.\nError: Download failed: server returned code <span class="token number">502</span>. URL: <a class="token url-link" href="https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip">https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip</a>\n</code></pre>\n<p>或者</p>\n<pre class="language-bash"><code class="language-bash">ERROR: Failed to download Chromium r588429<span class="token operator">!</span> Set <span class="token string">"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD"</span> <span class="token function">env</span> variable to skip download.\n<span class="token punctuation">{</span> Error: connect ETIMEDOUT <span class="token number">172.217</span>.24.48:443\n</code></pre>\n<p>如提示所说，设置 <code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD</code> 可以跳过安装 Chromium。</p>\n<pre class="language-bash"><code class="language-bash"><span class="token assign-left variable">PUPPETEER_SKIP_CHROMIUM_DOWNLOAD</span><span class="token operator">=</span><span class="token number">1</span> <span class="token function">npm</span> <span class="token function">install</span> puppeteer --save-dev\n</code></pre>\n<p>此时可以安装成功，但是使用 Puppeteer 时会由于找不到 Chromium 而报错。可以创建一个文件 <code>test.js</code>，内容如下：</p>\n<pre class="language-js"><code class="language-js"><span class="token keyword">const</span> puppeteer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'puppeteer\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token arrow operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> browser <span class="token operator">=</span> <span class="token keyword control-flow">await</span> puppeteer<span class="token punctuation">.</span><span class="token method function property-access">launch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">const</span> page <span class="token operator">=</span> <span class="token keyword control-flow">await</span> browser<span class="token punctuation">.</span><span class="token method function property-access">newPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">await</span> page<span class="token punctuation">.</span><span class="token method function property-access">goto</span><span class="token punctuation">(</span><span class="token string">\'<a class="token url-link" href="https://example.com">https://example.com</a>\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword control-flow">await</span> page<span class="token punctuation">.</span><span class="token method function property-access">screenshot</span><span class="token punctuation">(</span><span class="token punctuation">{</span>path<span class="token operator">:</span> <span class="token string">\'example.png\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token keyword control-flow">await</span> browser<span class="token punctuation">.</span><span class="token method function property-access">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>然后执行 <code>node test.js</code> 则会报错：</p>\n<pre class="language-bash"><code class="language-bash">$ node test.js\n<span class="token punctuation">(</span>node:18368<span class="token punctuation">)</span> UnhandledPromiseRejectionWarning: Unhandled promise rejection <span class="token punctuation">(</span>rejection id: <span class="token number">1</span><span class="token punctuation">)</span>: Error: Chromium revision is not downloaded. Run <span class="token string">"npm install"</span> or <span class="token string">"yarn install"</span>\n<span class="token punctuation">(</span>node:18368<span class="token punctuation">)</span> <span class="token punctuation">[</span>DEP0018<span class="token punctuation">]</span> DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero <span class="token builtin class-name">exit</span> code.\n</code></pre>\n<p>一个解决方案是先手动下载 Chromium，然后在执行时通过配置指定 Chromium 位置，<a href="https://juejin.im/post/5b4a043751882519790c7ad7">这篇文章</a>给出了解决步骤。</p>\n<p>但是我更倾向于还原 Puppeteer 安装时的过程。但是由于一些环境原因，即便翻墙了也只能手动下载 Chromium，无法在安装 Puppeteer 时自动下载 Chromium。</p>\n<p>读了一下源码之后，可以这么解决：</p>\n<ol>\n<li>安装 Puppeteer，安装失败，提示无法下载 <code>https://storage.googleapis.com/chromium-browser-snapshots/Win_x64/588429/chrome-win32.zip</code></li>\n<li>使用 <code>PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=1 npm install puppeteer --save-dev</code> 成功安装 Puppeteer</li>\n<li>执行 <code>node test.js</code> 提示无法找到 Chromium</li>\n<li>手动下载步骤 1 中的 <code>chrome-win32.zip</code>，注意不同版本、不同系统的下载地址是不一样的</li>\n<li>开启一个静态文件服务，使得 <code>http://127.0.0.1:8000/chrome-win32.zip</code> 指向需要下载的文件</li>\n<li>改写 <code>downloadURL</code> 方法，使其直接返回 <code>http://127.0.0.1:8000/chrome-win32.zip</code></li>\n<li>执行 <code>node ./node_modules/puppeteer/install.js</code> 完成安装</li>\n<li>执行 <code>node test.js</code> 测试能否成功生成截图</li>\n</ol>\n<p>至此，成功完成了 Puppeteer 的安装。</p>\n<h2 id="puppeteer-%E7%BB%93%E6%9E%84">Puppeteer 结构<a class="anchor" href="#puppeteer-%E7%BB%93%E6%9E%84">§</a></h2>\n<p>Puppeteer 通过 DevTools 协议控制 Chromium/Chrome 浏览器。它的结构和浏览器结构类似。</p>\n<blockquote>\n<p>下图中淡化显示的可以忽略</p>\n</blockquote>\n<p><img src="../assets/puppeteer_turorial/puppeteer-structure.png" alt="Puppeteer 结构"></p>\n<ul>\n<li>Puppeteer 通过 DevTools 协议控制 Chromium/Chrome 浏览器</li>\n<li>一个浏览器（Browser）实例可以包含多个浏览器上下文（Browser contexts），就像我们打开一个普通的 Chrome 之后又打开一个隐身模式的 Chrome</li>\n<li>一个浏览器上下文（BrowserContext）可以包含多个页面（Pages）</li>\n<li>一个页面（Page）包含至少一个主 frame，也可以包含其他 frames（在主 frame 中通过 iframe 或 frame 标签创建的）</li>\n<li>一个 frame 包含至少一个执行上下文（Execution context），也可以包含其他执行上下文（由 Chrome 插件创建的）</li>\n<li>一个 Workder 包含一个执行上下文，由 WebWorker 创建</li>\n</ul>\n<h2 id="puppeteer-api">Puppeteer API<a class="anchor" href="#puppeteer-api">§</a></h2>\n<p>Puppeteer 的大部分 API 的返回值都是 <code>Promise</code>，故推荐使用 <code>async</code> <code>await</code> 来处理异步操作。Puppeteer 的 API 包含以下类：</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>类名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Puppeteer</code></td>\n<td>主要用于创建一个浏览器实例，也可以用来下载新的 Chromium，或者设置浏览器的默认参数</td>\n</tr>\n<tr>\n<td><code>BrowserFetcher</code></td>\n<td>用于下载和管理 Chromium</td>\n</tr>\n<tr>\n<td><code>Browser</code></td>\n<td>可以创建一个或多个 Page</td>\n</tr>\n<tr>\n<td><code>BrowserContext</code></td>\n<td>创建一个隐身模式的浏览器时需要用到</td>\n</tr>\n<tr>\n<td><code>Page</code></td>\n<td><strong>主要 API，用于操作一个页面，后面会详细介绍</strong></td>\n</tr>\n<tr>\n<td><code>Worker</code></td>\n<td>用于处理 WebWorker</td>\n</tr>\n<tr>\n<td><code>Keyboard</code></td>\n<td>可以触发键盘按键</td>\n</tr>\n<tr>\n<td><code>Mouse</code></td>\n<td>可以触发鼠标动作</td>\n</tr>\n<tr>\n<td><code>TouchScreen</code></td>\n<td>可以触发触摸屏的动作</td>\n</tr>\n<tr>\n<td><code>Tracing</code></td>\n<td>用于分析性能</td>\n</tr>\n<tr>\n<td><code>Dialog</code></td>\n<td>存在于 page 的 <code>dialog</code> 事件回调中，表示调用弹窗后的对象，包括 <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> 和 <code>prompt</code></td>\n</tr>\n<tr>\n<td><code>ConsoleMessage</code></td>\n<td>存在于 page 的 <code>console</code> 事件回调中，表示调用 <code>console.log</code> 等方法后的对象</td>\n</tr>\n<tr>\n<td><code>Frame</code></td>\n<td>常用于处理包含多个 frame 的页面。page 中的很多方法就是直接调用的主 frame 的方法</td>\n</tr>\n<tr>\n<td><code>ExecutionContext</code></td>\n<td>执行上下文存在于 frame、浏览器插件、worker 中。可以用来直接执行一段 js</td>\n</tr>\n<tr>\n<td><code>JSHandle</code></td>\n<td>通过 <code>page.evaluateHandle</code> 生成，用于将页面中的 handler 挑出来传递使用</td>\n</tr>\n<tr>\n<td><code>ElementHandle</code></td>\n<td>通过 <code>page.$</code> 生成，用于将页面中某个元素的 handler 挑出来传递使用</td>\n</tr>\n<tr>\n<td><code>Request</code></td>\n<td>在 <code>page.setRequestInterception</code> 方法中使用，可以处理页面的请求</td>\n</tr>\n<tr>\n<td><code>Response</code></td>\n<td>表示页面接收到的响应</td>\n</tr>\n<tr>\n<td><code>SecurityDetails</code></td>\n<td>表示页面的安全信息</td>\n</tr>\n<tr>\n<td><code>Target</code></td>\n<td>可以是 page, background_page, service_worker, browser 等</td>\n</tr>\n<tr>\n<td><code>CDPSession</code></td>\n<td>用于直接和 Devtools 通信</td>\n</tr>\n<tr>\n<td><code>Coverage</code></td>\n<td>用于分析 js 和 css 的代码被页面使用的比例</td>\n</tr>\n<tr>\n<td><code>TimeoutError</code></td>\n<td>超时错误</td>\n</tr>\n</tbody>\n</table></div>\n<h3 id="page">Page<a class="anchor" href="#page">§</a></h3>\n<p>Page 是 Puppeteer 中最重要的一个 API，也是它的核心所在，这里会介绍一些常用的 Page API。</p>\n<h4 id="%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%8E%AF%E5%A2%83">设置页面环境<a class="anchor" href="#%E8%AE%BE%E7%BD%AE%E9%A1%B5%E9%9D%A2%E7%8E%AF%E5%A2%83">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.emulate</code></td>\n<td>设置 viewport 和 ua</td>\n</tr>\n<tr>\n<td><code>page.setViewport</code></td>\n<td>设置 viewport</td>\n</tr>\n<tr>\n<td><code>page.setUserAgent</code></td>\n<td>设置 ua</td>\n</tr>\n<tr>\n<td><code>page.setRequestInterception</code></td>\n<td><strong>中断所有请求，并可以修改请求的返回值</strong></td>\n</tr>\n<tr>\n<td><code>page.addScriptTag</code></td>\n<td>添加 js 脚本</td>\n</tr>\n<tr>\n<td><code>page.addStyleTag</code></td>\n<td>添加 css</td>\n</tr>\n<tr>\n<td><code>page.setContent</code></td>\n<td>设置整个 html</td>\n</tr>\n<tr>\n<td><code>page.setCacheEnabled</code></td>\n<td>设置缓存是否开启</td>\n</tr>\n<tr>\n<td><code>page.setExtraHTTPHeaders</code></td>\n<td>设置额外的 http 头</td>\n</tr>\n<tr>\n<td><code>page.setGeolocation</code></td>\n<td>设置地理位置</td>\n</tr>\n<tr>\n<td><code>page.setJavaScriptEnabled</code></td>\n<td>设置 js 是否开启</td>\n</tr>\n<tr>\n<td><code>page.setOfflineMode</code></td>\n<td>设置离线模式</td>\n</tr>\n<tr>\n<td><code>page.deleteCookie</code></td>\n<td>删除 cookies</td>\n</tr>\n<tr>\n<td><code>page.setCookie</code></td>\n<td>设置 cookies</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E6%A8%A1%E6%8B%9F%E5%8A%A8%E4%BD%9C">模拟动作<a class="anchor" href="#%E6%A8%A1%E6%8B%9F%E5%8A%A8%E4%BD%9C">§</a></h4>\n<p>一般会先滚动视窗到相应元素那，再执行动作。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.click</code></td>\n<td>点击</td>\n</tr>\n<tr>\n<td><code>page.tap</code></td>\n<td>手指点击</td>\n</tr>\n<tr>\n<td><code>page.focus</code></td>\n<td>聚焦</td>\n</tr>\n<tr>\n<td><code>page.hover</code></td>\n<td>hover</td>\n</tr>\n<tr>\n<td><code>page.type</code></td>\n<td>在指定元素中输入内容</td>\n</tr>\n<tr>\n<td><code>page.select</code></td>\n<td>选中 <code>&lt;select&gt;</code> 的某个选项</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E7%AD%89%E5%BE%85">等待<a class="anchor" href="#%E7%AD%89%E5%BE%85">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.waitFor</code></td>\n<td>等待某个元素渲染出来，或者某个函数执行之后返回 <code>true</code>，或者直接等待指定的时间</td>\n</tr>\n<tr>\n<td><code>page.waitForSelector</code></td>\n<td>等待某个元素被渲染</td>\n</tr>\n<tr>\n<td><code>page.waitForFunction</code></td>\n<td>等待某个函数执行之后返回 <code>true</code></td>\n</tr>\n<tr>\n<td><code>page.waitForNavigation</code></td>\n<td>等待页面跳转</td>\n</tr>\n<tr>\n<td><code>page.waitForRequest</code></td>\n<td>等待某个特定的请求被发出</td>\n</tr>\n<tr>\n<td><code>page.waitForResponse</code></td>\n<td>等待某个特定的请求收到了回应</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC">执行脚本<a class="anchor" href="#%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.$</code></td>\n<td>使用 <code>document.querySelector</code> 获取结果，会返回 <code>ElementHandle</code>，可以传递使用</td>\n</tr>\n<tr>\n<td><code>page.$$</code></td>\n<td>同上，不过使用的是 <code>document.querySelectorAll</code></td>\n</tr>\n<tr>\n<td><code>page.$eval</code></td>\n<td>将 <code>document.querySelector</code> 获取的结果传递给 <code>pageFunction</code></td>\n</tr>\n<tr>\n<td><code>page.$$eval</code></td>\n<td>同上，不过使用的是 <code>document.querySelectorAll</code></td>\n</tr>\n<tr>\n<td><code>page.evaluate</code></td>\n<td>直接执行脚本</td>\n</tr>\n<tr>\n<td><code>page.evaluateHandle</code></td>\n<td>执行脚本，返回的是 <code>JSHandle</code>，可以传递使用</td>\n</tr>\n<tr>\n<td><code>page.evaluateOnNewDocument</code></td>\n<td>在下个 frame 执行脚本</td>\n</tr>\n<tr>\n<td><code>page.exposeFunction</code></td>\n<td>将函数注入到 <code>window</code> 对象上</td>\n</tr>\n<tr>\n<td><code>page.queryObjects</code></td>\n<td>获取所有属于这个类的对象，可以传递使用</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC">页面跳转<a class="anchor" href="#%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.goto</code></td>\n<td>跳转页面</td>\n</tr>\n<tr>\n<td><code>page.close</code></td>\n<td>关闭</td>\n</tr>\n<tr>\n<td><code>page.goBack</code></td>\n<td>后退</td>\n</tr>\n<tr>\n<td><code>page.goForward</code></td>\n<td>前进</td>\n</tr>\n<tr>\n<td><code>page.reload</code></td>\n<td>刷新</td>\n</tr>\n<tr>\n<td><code>page.setDefaultNavigationTimeout</code></td>\n<td>设置页面跳转的超时时长</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9">获取内容<a class="anchor" href="#%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.screenshot</code></td>\n<td>截屏</td>\n</tr>\n<tr>\n<td><code>page.pdf</code></td>\n<td>生成 pdf</td>\n</tr>\n<tr>\n<td><code>page.content</code></td>\n<td>获取整个页面内容</td>\n</tr>\n<tr>\n<td><code>page.title</code></td>\n<td>获取页面 title</td>\n</tr>\n<tr>\n<td><code>page.url</code></td>\n<td>获取页面 url</td>\n</tr>\n<tr>\n<td><code>page.viewport</code></td>\n<td>获取页面 viewport</td>\n</tr>\n<tr>\n<td><code>page.cookies</code></td>\n<td>获取 cookies</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E4%BA%8B%E4%BB%B6">事件<a class="anchor" href="#%E4%BA%8B%E4%BB%B6">§</a></h4>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>事件名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.on(\'console\')</code></td>\n<td>监听 <code>console.log</code> 等的调用</td>\n</tr>\n<tr>\n<td><code>page.on(\'dialog\')</code></td>\n<td>监听页面的 <code>alert</code>, <code>beforeunload</code>, <code>confirm</code> 和 <code>prompt</code> 弹窗</td>\n</tr>\n<tr>\n<td><code>page.on(\'load\')</code></td>\n<td>监听页面的加载</td>\n</tr>\n<tr>\n<td><code>page.on(\'domcontentloaded\')</code></td>\n<td>监听页面 dom 加载完成</td>\n</tr>\n<tr>\n<td><code>page.on(\'pageerror\')</code></td>\n<td>监听页面错误</td>\n</tr>\n<tr>\n<td><code>page.on(\'request\')</code></td>\n<td>监听页面发送的请求</td>\n</tr>\n<tr>\n<td><code>page.on(\'requestfailed\')</code></td>\n<td>监听失败的请求</td>\n</tr>\n<tr>\n<td><code>page.on(\'requestfinished\')</code></td>\n<td>监听完成的请求</td>\n</tr>\n<tr>\n<td><code>page.on(\'response\')</code></td>\n<td>监听页面接受到的响应</td>\n</tr>\n</tbody>\n</table></div>\n<h4 id="%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">命名空间<a class="anchor" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">§</a></h4>\n<p>通过一些命名空间可以快速访问到该页面下的其他实例。</p>\n<div class="table_wrapper"><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>page.keyboard</code></td>\n<td>访问到页面的 Keyboard 对象</td>\n</tr>\n<tr>\n<td><code>page.mouse</code></td>\n<td>访问到页面的 Mouse 对象</td>\n</tr>\n<tr>\n<td><code>page.touchscreen</code></td>\n<td>访问到页面的 TouchScreen 对象</td>\n</tr>\n</tbody>\n</table></div>\n<h2 id="links">Links<a class="anchor" href="#links">§</a></h2>\n<ul>\n<li><a href="https://pptr.dev/">Puppeteer 文档</a></li>\n<li><a href="https://peter.sh/experiments/chromium-command-line-switches/">Chromium CLI 参数</a></li>\n<li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js">预设的 EmulateOptions</a></li>\n</ul>'
        } }),
    'toc': React.createElement("nav", { key: "0", className: "toc" },
        React.createElement("ol", null,
            React.createElement("li", null,
                React.createElement("a", { href: "#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8" }, "\u4EC0\u4E48\u662F\u65E0\u5934\u6D4F\u89C8\u5668")),
            React.createElement("li", null,
                React.createElement("a", { href: "#puppeteer-%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88" }, "Puppeteer \u80FD\u505A\u4EC0\u4E48")),
            React.createElement("li", null,
                React.createElement("a", { href: "#puppeteer-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%97%A0%E5%A4%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" }, "Puppeteer \u4E0E\u5176\u4ED6\u65E0\u5934\u6D4F\u89C8\u5668\u6709\u4EC0\u4E48\u533A\u522B\uFF1F")),
            React.createElement("li", null,
                React.createElement("a", { href: "#%E5%AE%89%E8%A3%85-puppeteer" }, "\u5B89\u88C5 Puppeteer")),
            React.createElement("li", null,
                React.createElement("a", { href: "#puppeteer-%E7%BB%93%E6%9E%84" }, "Puppeteer \u7ED3\u6784")),
            React.createElement("li", null,
                React.createElement("a", { href: "#puppeteer-api" }, "Puppeteer API"),
                React.createElement("ol", null,
                    React.createElement("li", null,
                        React.createElement("a", { href: "#page" }, "Page"),
                        React.createElement("ol", null)))),
            React.createElement("li", null,
                React.createElement("a", { href: "#links" }, "Links")))),
    'author': undefined,
    'contributors': [],
    'date': "2018-09-18T00:00:00.000Z",
    'updated': null,
    'excerpt': "Puppeteer 是 Google Chrome 出品的一个无头浏览器。如果你听说过 Phantomjs 或者 Selenium，那么就应该知道它是做什么的了。Puppeteer 与它们类似，提供了一系列 api，通过 DevTools 协议控制 Chromium/Chrome 浏览器的行为。...",
    'cover': "../assets/puppeteer_turorial/puppeteer-structure.png",
    'categories': [
        "编程世界"
    ],
    'tags': [
        "JavaScript",
        "Puppeteer"
    ],
    'blog': {
        "isPost": false,
        "posts": [],
        "categories": [],
        "tags": []
    }
};
